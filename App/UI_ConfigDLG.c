/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.30                          *
*        Compiled Jul  1 2015, 10:50:32                              *
*        (c) 2015 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
// USER END

#include "DIALOG.h"

/*********************************************************************
*
*       Defines
*
**********************************************************************
*/
#define ID_WINDOW_0      (GUI_ID_USER + 0x00)
#define ID_TEXT_0      (GUI_ID_USER + 0x04)
#define ID_TEXT_1      (GUI_ID_USER + 0x05)
#define ID_TEXT_2      (GUI_ID_USER + 0x06)
#define ID_EDIT_0      (GUI_ID_USER + 0x07)
#define ID_DROPDOWN_0      (GUI_ID_USER + 0x0C)
#define ID_EDIT_1      (GUI_ID_USER + 0x0F)
#define ID_TEXT_3      (GUI_ID_USER + 0x12)
#define ID_TEXT_4      (GUI_ID_USER + 0x14)
#define ID_BUTTON_0      (GUI_ID_USER + 0x16)
#define ID_TEXT_5      (GUI_ID_USER + 0x17)
#define ID_IMAGE_0      (GUI_ID_USER + 0x1B)
#define ID_IMAGE_1      (GUI_ID_USER + 0x1D)
#define ID_IMAGE_2      (GUI_ID_USER + 0x1E)
#define ID_DROPDOWN_1      (GUI_ID_USER + 0x1F)
#define ID_DROPDOWN_2      (GUI_ID_USER + 0x20)

#define ID_IMAGE_0_IMAGE_0      0x00
#define ID_IMAGE_1_IMAGE_0      0x01
#define ID_IMAGE_2_IMAGE_0      0x02

// USER START (Optionally insert additional defines)
// USER END

/*********************************************************************
*
*       Static data
*
**********************************************************************
*/
/*********************************************************************
*
*       _acImage_0, "BMP", ID_IMAGE_0_IMAGE_0
*/
static const U8 _acImage_0[463] = {
  0x42, 0x4D, 0xCE, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x01, 0x00, 0x00, 0x12, 0x0B, 0x00, 0x00,
  0x12, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21,
  0x40, 0x00, 0x90, 0x84, 0x21, 0x08, 0x42, 0x10, 0xC0, 0x00, 0x88, 0x42, 0x10, 0x84, 0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00,
  0x90, 0x84, 0x21, 0x08, 0x42, 0x10, 0xC0, 0x00, 0x88, 0x42, 0x10, 0x84, 0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84,
  0x21, 0x08, 0x42, 0x10, 0xC0, 0x00, 0x88, 0x42, 0x10, 0x84, 0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84, 0x21, 0x08,
  0x42, 0x10, 0xC0, 0x00, 0x88, 0x42, 0x10, 0x84, 0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84, 0x21, 0x08, 0x42, 0x10,
  0xC0, 0x00, 0x88, 0x42, 0x10, 0x84, 0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84, 0x21, 0x08, 0x42, 0x10, 0xC0, 0x00,
  0x88, 0x42, 0x10, 0x84, 0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84, 0x21, 0x08, 0x42, 0x10, 0xC0, 0x00, 0x88, 0x42,
  0x10, 0x84, 0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84, 0x21, 0x08, 0x42, 0x10, 0xC0, 0x00, 0x88, 0x42, 0x10, 0x84,
  0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84, 0x21, 0x08, 0x42, 0x10, 0xC0, 0x00, 0x88, 0x42, 0x10, 0x84, 0x21, 0x08,
  0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84, 0x21, 0x08, 0x42, 0x10, 0xC0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00,
  0x00,
};

/*********************************************************************
*
*       _acImage_1, "BMP", ID_IMAGE_1_IMAGE_0
*/
static const U8 _acImage_1[463] = {
  0x42, 0x4D, 0xCE, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x01, 0x00, 0x00, 0x12, 0x0B, 0x00, 0x00,
  0x12, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21,
  0x40, 0x00, 0x90, 0x84, 0x21, 0x08, 0x42, 0x10, 0xC0, 0x00, 0x88, 0x42, 0x10, 0x84, 0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00,
  0x90, 0x84, 0x21, 0x08, 0x42, 0x10, 0xC0, 0x00, 0x88, 0x42, 0x10, 0x84, 0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84,
  0x21, 0x08, 0x42, 0x10, 0xC0, 0x00, 0x88, 0x42, 0x10, 0x84, 0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84, 0x21, 0x08,
  0x42, 0x10, 0xC0, 0x00, 0x88, 0x42, 0x10, 0x84, 0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84, 0x21, 0x08, 0x42, 0x10,
  0xC0, 0x00, 0x88, 0x42, 0x10, 0x84, 0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84, 0x21, 0x08, 0x42, 0x10, 0xC0, 0x00,
  0x88, 0x42, 0x10, 0x84, 0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84, 0x21, 0x08, 0x42, 0x10, 0xC0, 0x00, 0x88, 0x42,
  0x10, 0x84, 0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84, 0x21, 0x08, 0x42, 0x10, 0xC0, 0x00, 0x88, 0x42, 0x10, 0x84,
  0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84, 0x21, 0x08, 0x42, 0x10, 0xC0, 0x00, 0x88, 0x42, 0x10, 0x84, 0x21, 0x08,
  0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84, 0x21, 0x08, 0x42, 0x10, 0xC0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00,
  0x00,
};

/*********************************************************************
*
*       _acImage_2, "BMP", ID_IMAGE_2_IMAGE_0
*/
static const U8 _acImage_2[463] = {
  0x42, 0x4D, 0xCE, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x01, 0x00, 0x00, 0x12, 0x0B, 0x00, 0x00,
  0x12, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21,
  0x40, 0x00, 0x90, 0x84, 0x21, 0x08, 0x42, 0x10, 0xC0, 0x00, 0x88, 0x42, 0x10, 0x84, 0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00,
  0x90, 0x84, 0x21, 0x08, 0x42, 0x10, 0xC0, 0x00, 0x88, 0x42, 0x10, 0x84, 0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84,
  0x21, 0x08, 0x42, 0x10, 0xC0, 0x00, 0x88, 0x42, 0x10, 0x84, 0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84, 0x21, 0x08,
  0x42, 0x10, 0xC0, 0x00, 0x88, 0x42, 0x10, 0x84, 0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84, 0x21, 0x08, 0x42, 0x10,
  0xC0, 0x00, 0x88, 0x42, 0x10, 0x84, 0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84, 0x21, 0x08, 0x42, 0x10, 0xC0, 0x00,
  0x88, 0x42, 0x10, 0x84, 0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84, 0x21, 0x08, 0x42, 0x10, 0xC0, 0x00, 0x88, 0x42,
  0x10, 0x84, 0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84, 0x21, 0x08, 0x42, 0x10, 0xC0, 0x00, 0x88, 0x42, 0x10, 0x84,
  0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84, 0x21, 0x08, 0x42, 0x10, 0xC0, 0x00, 0x88, 0x42, 0x10, 0x84, 0x21, 0x08,
  0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84, 0x21, 0x08, 0x42, 0x10, 0xC0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00,
  0x00,
};

// USER START (Optionally insert additional static data)
// USER END

/*********************************************************************
*
*       _aDialogCreate
*/
static const GUI_WIDGET_CREATE_INFO _aDialogCreate[] = {
  { WINDOW_CreateIndirect, "UI_Config", ID_WINDOW_0, 0, 0, 800, 480, 0, 0x0, 0 },
  { TEXT_CreateIndirect, "TextoriginWifi", ID_TEXT_0, 80, 20, 80, 20, 0, 0x64, 0 },
  { TEXT_CreateIndirect, "TextConfigWifi", ID_TEXT_1, 80, 45, 80, 20, 0, 0x64, 0 },
  { TEXT_CreateIndirect, "TextModel", ID_TEXT_2, 80, 100, 80, 20, 0, 0x64, 0 },
  { EDIT_CreateIndirect, "EditoriginWifi", ID_EDIT_0, 160, 20, 600, 20, 0, 0x50, 0 },
  { DROPDOWN_CreateIndirect, "DropdownModel", ID_DROPDOWN_0, 160, 100, 600, 21, 0, 0x0, 0 },
  { EDIT_CreateIndirect, "EditconfigWifi", ID_EDIT_1, 160, 45, 600, 20, 0, 0x50, 0 },
  { TEXT_CreateIndirect, "TextTesterID", ID_TEXT_3, 80, 240, 80, 20, 0, 0x64, 0 },
  { TEXT_CreateIndirect, "TextTesterName", ID_TEXT_4, 80, 265, 80, 20, 0, 0x64, 0 },
  { BUTTON_CreateIndirect, "ButtonConfirm", ID_BUTTON_0, 178, 331, 120, 52, 0, 0x0, 0 },
  { TEXT_CreateIndirect, "TextStateDisplay", ID_TEXT_5, 184, 404, 80, 20, 0, 0x64, 0 },
  { IMAGE_CreateIndirect, "ImageWifi", ID_IMAGE_0, 20, 18, 50, 50, 0, 0, 0 },
  { IMAGE_CreateIndirect, "ImageModel", ID_IMAGE_1, 20, 100, 44, 50, 0, 0, 0 },
  { IMAGE_CreateIndirect, "ImageTester", ID_IMAGE_2, 20, 240, 50, 50, 0, 0, 0 },
  { DROPDOWN_CreateIndirect, "DropdownTestID", ID_DROPDOWN_1, 200, 240, 120, 21, 0, 0x0, 0 },
  { DROPDOWN_CreateIndirect, "DropdownTestName", ID_DROPDOWN_2, 200, 265, 120, 21, 0, 0x0, 0 },
  // USER START (Optionally insert additional widgets)
  // USER END
};

/*********************************************************************
*
*       Static code
*
**********************************************************************
*/
/*********************************************************************
*
*       _GetImageById
*/
static const void * _GetImageById(U32 Id, U32 * pSize) {
  switch (Id) {
  case ID_IMAGE_0_IMAGE_0:
    *pSize = sizeof(_acImage_0);
    return (const void *)_acImage_0;
  case ID_IMAGE_1_IMAGE_0:
    *pSize = sizeof(_acImage_1);
    return (const void *)_acImage_1;
  case ID_IMAGE_2_IMAGE_0:
    *pSize = sizeof(_acImage_2);
    return (const void *)_acImage_2;
  }
  return NULL;
}

// USER START (Optionally insert additional static code)
#undef GUI_MAKE_COLOR
#define GUI_MAKE_COLOR
extern WM_HWIN AllWindows[3];
extern GUI_CONST_STORAGE GUI_FONT GBK_16m16;
#define GUI_FONT_16B_1 &GBK_16m16
extern GUI_BITMAP StdImgBitMap;
#include "string.h"
#include "stdlib.h"
#include "stm32f4xx.h"
#include "App_main.h"
#include "bitmap.h"
#include "skin.h"
#include "WifiCommu.h"
#include "ff.h"
#include "TestFuncs.h"
#include "usart.h"
#include "fattester.h"
#include "FreeRTOS.h"
#include "semphr.h"

extern SemaphoreHandle_t xBinaryHandleWIFINETCONNECT;

#define MODELDROPDOWN ID_DROPDOWN_0
#define TESTIDDROPDOWN ID_DROPDOWN_1
#define TESTNAMEDROPDOWN ID_DROPDOWN_2
#define StateDisplayText ID_TEXT_5
static void AddModelSelectDropDown(WM_HWIN hWin,int objID, xTestSelection *pTestModel);
static void ModuleTestConfig(WM_HWIN hWin);
static void WifiConnectConfig(WM_HWIN hWin);
// USER END

/*********************************************************************
*
*       _cbDialog
*/
static void _cbDialog(WM_MESSAGE * pMsg) {
  const void * pData;
  WM_HWIN      hItem;
  U32          FileSize;
  int          NCode;
  int          Id;
  // USER START (Optionally insert additional variables)
  // USER END

  switch (pMsg->MsgId) {
  case WM_INIT_DIALOG:
    //
    // Initialization of 'UI_Config'
    //
    hItem = pMsg->hWin;
    WINDOW_SetBkColor(hItem, GUI_MAKE_COLOR(0x00EAEAEA));
    //
    // Initialization of 'TextoriginWifi'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_0);
    TEXT_SetText(hItem, "当前状态");
    TEXT_SetFont(hItem, GUI_FONT_16B_1);
    //
    // Initialization of 'TextConfigWifi'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_1);
    TEXT_SetText(hItem, "配置状态");
    TEXT_SetFont(hItem, GUI_FONT_16B_1);
    //
    // Initialization of 'TextModel'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_2);
    TEXT_SetText(hItem, "型号规格");
    TEXT_SetFont(hItem, GUI_FONT_16B_1);
    //
    // Initialization of 'EditoriginWifi'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_EDIT_0);
//    EDIT_SetText(hItem, "0");
    EDIT_SetText(hItem, pTestconfig->defaultwifimsg);
    EDIT_SetTextColor(hItem, EDIT_CI_ENABLED, GUI_MAKE_COLOR(0x00FF0000));
    //
    // Initialization of 'DropdownModel'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_DROPDOWN_0);
    DROPDOWN_SetListHeight(hItem, 350);
    DROPDOWN_SetFont(hItem, GUI_FONT_16B_1);
    AddModelSelectDropDown(pMsg->hWin,ID_DROPDOWN_0,pTestconfig);
    //
    // Initialization of 'EditconfigWifi'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_EDIT_1);
//    EDIT_SetText(hItem, "0");
    EDIT_SetText(hItem, pTestconfig->configwifimsg);
    EDIT_SetTextColor(hItem, EDIT_CI_ENABLED, GUI_MAKE_COLOR(0x000000FF));
    //
    // Initialization of 'TextTesterID'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_3);
    TEXT_SetText(hItem, "测试人ID");
    TEXT_SetFont(hItem, GUI_FONT_16B_1);
    //
    // Initialization of 'TextTesterName'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_4);
    TEXT_SetText(hItem, "测试人姓名");
    TEXT_SetFont(hItem, GUI_FONT_16B_1);
    //
    // Initialization of 'ButtonConfirm'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_0);
    BUTTON_SetFont(hItem, GUI_FONT_16B_1);
    BUTTON_SetText(hItem, "确认");
    //
    // Initialization of 'TextStateDisplay'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_5);
    TEXT_SetFont(hItem, GUI_FONT_16B_1);
    TEXT_SetText(hItem, "0");
    //
    // Initialization of 'ImageWifi'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_IMAGE_0);
//    pData = _GetImageById(ID_IMAGE_0_IMAGE_0, &FileSize);
//    IMAGE_SetBMP(hItem, pData, FileSize);
    IMAGE_SetBitmap(hItem, &bmwifi);
    //
    // Initialization of 'ImageModel'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_IMAGE_1);
//    pData = _GetImageById(ID_IMAGE_1_IMAGE_0, &FileSize);
//    IMAGE_SetBMP(hItem, pData, FileSize);
    IMAGE_SetBitmap(hItem, &bmfgp);
    //
    // Initialization of 'ImageTester'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_IMAGE_2);
//    pData = _GetImageById(ID_IMAGE_2_IMAGE_0, &FileSize);
//    IMAGE_SetBMP(hItem, pData, FileSize);
    IMAGE_SetBitmap(hItem, &bmtester);
    //
    // Initialization of 'DropdownTestID'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_DROPDOWN_1);
//    DROPDOWN_AddString(hItem, "ID1");
    AddModelSelectDropDown(pMsg->hWin,ID_DROPDOWN_1,pTestconfig);
    DROPDOWN_SetFont(hItem, GUI_FONT_16B_1);
    DROPDOWN_SetListHeight(hItem, 200);
    //
    // Initialization of 'DropdownTestName'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_DROPDOWN_2);
//    DROPDOWN_AddString(hItem, "Name1");
    AddModelSelectDropDown(pMsg->hWin,ID_DROPDOWN_2,pTestconfig);
    DROPDOWN_SetFont(hItem, GUI_FONT_16B_1);
    DROPDOWN_SetListHeight(hItem, 200);
    // USER START (Optionally insert additional code for further widget initialization)
    // USER END
    break;
  case WM_NOTIFY_PARENT:
    Id    = WM_GetId(pMsg->hWinSrc);
    NCode = pMsg->Data.v;
    switch(Id) {
    case ID_EDIT_0: // Notifications sent by 'EditoriginWifi'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_VALUE_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_DROPDOWN_0: // Notifications sent by 'DropdownModel'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_SEL_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_EDIT_1: // Notifications sent by 'EditconfigWifi'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_VALUE_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_0: // Notifications sent by 'ButtonConfirm'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
  		hItem = WM_GetDialogItem(pMsg->hWin, StateDisplayText);
  		TEXT_SetText(hItem, "正在配置模组..");
  		GUI_Delay(3);
  		ModuleTestConfig(pMsg->hWin);

  		hItem = WM_GetDialogItem(pMsg->hWin, StateDisplayText);
  		TEXT_SetText(hItem, "正在配置wifi..");
  		GUI_Delay(3);
  		WifiConnectConfig(pMsg->hWin);
  		xSemaphoreGive( xBinaryHandleWIFINETCONNECT );

  		free(pTestconfig);
  		CreateTestList();
        //切换页面
        WM_HideWindow(AllWindows[0]);       //隐藏Page 0
        WM_ShowWindow(AllWindows[1]);
        WM_SetFocus(AllWindows[1]);
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_DROPDOWN_1: // Notifications sent by 'DropdownTestID'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_SEL_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_DROPDOWN_2: // Notifications sent by 'DropdownTestName'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_SEL_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    // USER START (Optionally insert additional code for further Ids)
    // USER END
    }
    break;
  // USER START (Optionally insert additional message handling)
  // USER END
  default:
    WM_DefaultProc(pMsg);
    break;
  }
}

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       CreateUI_Config
*/
WM_HWIN CreateUI_Config(void);
WM_HWIN CreateUI_Config(void) {
  WM_HWIN hWin;

  hWin = GUI_CreateDialogBox(_aDialogCreate, GUI_COUNTOF(_aDialogCreate), _cbDialog, WM_HBKWIN, 0, 0);
  return hWin;
}

// USER START (Optionally insert additional public code)
static void AddModelSelectDropDown(WM_HWIN hWin,int objID, xTestSelection *pTestModel)
{
	WM_HWIN hItem = WM_GetDialogItem(hWin, objID);
	switch(objID){
		case MODELDROPDOWN:
			if(pTestModel->model[0]==0){
				DROPDOWN_AddString(hItem,"No Std Files.");
			}else{
				for(int i=0;i<MAX_MODELSELECT_NUM;i++){
					if(pTestModel->model[i]!=NULL)
						DROPDOWN_AddString(hItem,pTestModel->model[i]);
				}
			}
			break;
		case TESTIDDROPDOWN:
			if(pTestModel->testid[0]==0){
				DROPDOWN_AddString(hItem,"No Std Files.");
			}else{
				for(int i=0;i<MAX_TESTNUM;i++){
					if(pTestModel->testid[i]!=NULL)
						DROPDOWN_AddString(hItem,pTestModel->testid[i]);
				}
			}
			break;
		case TESTNAMEDROPDOWN:
			if(pTestModel->testname[0]==0){
				DROPDOWN_AddString(hItem,"No Std Files.");
			}else{
				for(int i=0;i<MAX_TESTNUM;i++){
					if(pTestModel->testname[i]!=NULL)
						DROPDOWN_AddString(hItem,pTestModel->testname[i]);
				}
			}
			break;
		default:
			break;
	}
}

static void ModuleTestConfig(WM_HWIN hWin)
{
	WM_HWIN hItem;
	int selected;

	hItem = WM_GetDialogItem(hWin, TESTIDDROPDOWN);
	selected = DROPDOWN_GetSel(hItem);
	if(DROPDOWN_GetItemText(hItem,selected,hteststate.theResult->testerid,8)!=0){
		assert_failed(__FILE__,__LINE__);
		strcpy(hteststate.theResult->testerid,"get fail");
	}

	hItem = WM_GetDialogItem(hWin, TESTNAMEDROPDOWN);
	selected = DROPDOWN_GetSel(hItem);
	if(DROPDOWN_GetItemText(hItem,selected,hteststate.theResult->testername,49)!=0){
		assert_failed(__FILE__,__LINE__);
		strcpy(hteststate.theResult->Models,"get fail");
	}

	hItem = WM_GetDialogItem(hWin, MODELDROPDOWN);
	selected = DROPDOWN_GetSel(hItem);
	if(DROPDOWN_GetItemText(hItem,selected,hteststate.theResult->Models,49)!=0){
		assert_failed(__FILE__,__LINE__);
		strcpy(hteststate.theResult->Models,"get fail");
		hteststate.testconfigs = 0;
		return ;
	}


	uint32_t br;
	FIL fconfig;
	FRESULT fres;
	char *p;

	char tempstring[100];
	sprintf(tempstring,"0:/2.Moudle/%s.txt",hteststate.theResult->Models);
	fres = f_open(&fconfig,tempstring,FA_OPEN_EXISTING|FA_READ);
	if(fres != FR_OK){
		assert_failed("config file open fail\r\n",0);
		assert_failed(__FILE__,__LINE__);
	}

	char *tempbuff=(char *)malloc(1000);
	fres = f_read(&fconfig,tempbuff,1000,&br);
	if(fres != FR_OK){
		assert_failed(__FILE__,__LINE__);
	}

	for (p=tempbuff;*p!=0;p++)
	{
		if(*p!='[')
			continue;
		switch(*(p+1))
		{
			case '1':
				while(*p++!=']');				//忽略中间说明字符，判断 [x ]:
				if(*p++ == ':')
				{
					if(*p>'0' && *p<'4'){
						hteststate.moduletype = *p-'0';
					}else
						hteststate.moduletype = 0;
				}
				break;

			case '2':
				while(*p++!=']');				//忽略中间说明字符，判断 [x ]:
				if(*p++ == ':')
				{
					hteststate.testconfigs &= ~(uint32_t)CONFIG_XORCHECK;
					if(*p=='Y'){
						while(*p++ != ' ');
						char *ppsate=tempstring;
						while(*p!=0x0d && *p!=0x0a && *p!=0)
							*ppsate++=*p++;
						*ppsate++=0;
						char tempstring2[150];
						sprintf(tempstring2,"0:/2.Moudle/%s\0",tempstring);
						FIL fbinchek;
						if(f_open(&fbinchek,tempstring2,FA_OPEN_EXISTING|FA_READ)==FR_OK){
							hteststate.testconfigs |= CONFIG_XORCHECK;
							strcpy(hteststate.theResult->Binfiles,tempstring);
							f_close(&fbinchek);
						}
					}
				}
				break;
			case '3':
				while(*p++!=']');
				if(*p++ == ':')
				{
					hteststate.testconfigs &= ~(uint32_t)CONFIG_TVCCPOWER;
					if(*p=='Y'){
						while(*p++ != ' ');

						int32_t temptotrans=0;
						while(*p != ' ' && *p != 0x0)
						{
							if(*p=='.')p++;
							temptotrans = temptotrans*10+*p-'0';
							p++;
						}
						hteststate.staticpowerThreshold_default = (float)temptotrans*0.1;

						p++;
						temptotrans = 0;
						while(*p != 0x0d &&*p != 0x0a && *p != 0x0 && *p != ' ')
						{
							if(*p=='.')p++;
							temptotrans = temptotrans*10+*p-'0';
							p++;
						}
						hteststate.staticpowerThreshold_withurge = (float)temptotrans*0.1;

						hteststate.testconfigs |= CONFIG_TVCCPOWER;
					}
				}
				hteststate.dynamicpowerstep = 50;		//default = 200ms
				break;
			case '4':
				while(*p++!=']');
				if(*p++ == ':')
				{
					hteststate.testconfigs &= ~(uint32_t)CONFIG_MVCCPOWER;
					if(*p=='Y'){
						while(*p++ != ' ');

						int32_t temptotrans=0;
						while(*p != ' ' && *p != 0x0)
						{
							if(*p=='.')p++;
							temptotrans = temptotrans*10+*p-'0';
							p++;
						}
						hteststate.dynamicpowerThreshold_default = (float)temptotrans*0.1;

						p++;
						temptotrans = 0;
						while(*p != 0x0d &&*p != 0x0a && *p != 0x0 && *p != ' ')
						{
							if(*p=='.')p++;
							temptotrans = temptotrans*10+*p-'0';
							p++;
						}
						hteststate.dynamicpowerThreshold_withurge = (float)temptotrans*0.1;

						hteststate.testconfigs |= CONFIG_MVCCPOWER;
					}
				}
				hteststate.staticpowerstep = 166;		//default = 166
				break;
			case '5':
				while(*p++!=']');				//忽略中间说明字符，判断 [x ]:
				if(*p++ == ':')
				{
					hteststate.testconfigs &= ~(uint32_t)CONFIG_TOUCH;

					if(*p=='Y'){
						hteststate.testconfigs |= CONFIG_TOUCH;
					}
				}
				break;
			case '6':
				while(*p++!=']');				//忽略中间说明字符，判断 [x ]:
				if(*p++ == ':')
				{
					hteststate.testconfigs &= ~(uint32_t)CONFIG_STARTDUARTION;
					hteststate.StdStartDuartion = 0;

					if(*p=='Y'){
						while(*p++ != ' ');

						while(*p != 0x0d &&*p != 0x0a &&*p != ' '&& *p != 0x0)
						{
							hteststate.StdStartDuartion = hteststate.StdStartDuartion * 10 + *p-'0';
							p++;
						}
						hteststate.testconfigs |= CONFIG_STARTDUARTION;
					}
				}
				break;
			case '7':
				while(*p++!=']');				//忽略中间说明字符，判断 [x ]:
				if(*p++ == ':')
				{
					hteststate.testconfigs &= ~(uint32_t)CONFIG_GETVERSION;

					if(*p=='Y'){
						hteststate.testconfigs |= CONFIG_GETVERSION;
					}
				}
				break;
			case '8':
				while(*p++!=']');				//忽略中间说明字符，判断 [x ]:
				if(*p++ == ':')
				{
					hteststate.testconfigs &= ~(uint32_t)CONFIG_CALIBAUD;

					if(*p=='Y'){
						while(*p++ != ' ');

						while(*p != 0x0d &&*p != 0x0a &&*p != ' ' && *p != 0x0)
						{
							hteststate.targetbaudrate = hteststate.targetbaudrate * 10 + *p-'0';
							p++;
						}

						hteststate.testconfigs |= CONFIG_CALIBAUD;
					}
				}
				break;
			case '9':
				while(*p++!=']');				//忽略中间说明字符，判断 [x ]:
				if(*p++ == ':')
				{
					hteststate.testconfigs &= ~(uint32_t)CONFIG_FLASH;

					if(*p=='Y'){
						hteststate.testconfigs |= CONFIG_FLASH;
					}
				}
				break;
			case 'A':
				while(*p++!=']');				//忽略中间说明字符，判断 [x ]:
				if(*p++ == ':')
				{
					hteststate.testconfigs &= ~(uint32_t)CONFIG_GETIMAGE;

					if(*p=='Y'){
						hteststate.testconfigs |= CONFIG_GETIMAGE;
					}
				}
				break;
			case 'B':
				while(*p++!=']');				//忽略中间说明字符，判断 [x ]:
				if(*p++ == ':')
				{
					hteststate.testconfigs &= ~(uint32_t)CONFIG_LED;

					if(*p=='Y'){
						hteststate.testconfigs |= CONFIG_LED;
					}
				}
				break;
			default:
				assert_failed(__FILE__,__LINE__);
				break;
		}
	}
	free(tempbuff);
	fres = f_close(&fconfig);
	if(fres != FR_OK){
		assert_failed(__FILE__,__LINE__);
	}



}

static void WifiConnectConfig(WM_HWIN hWin)
{
	if((SysStates.wifistates & WIFIUARTCONNECT) && strcmp(pTestconfig->defaultwifimsg,pTestconfig->configwifimsg)!=0) //配置新的wifi
    {
		xSSIDItem theSSID;//={"prejoy123","123456789",100,8899,{192,168,23,1},0};
		memset(&theSSID,0,sizeof(theSSID));
		char *pcopy=pTestconfig->configwifimsg,*psate=theSSID.thsSSID;
		while(*pcopy!=',')
			*psate++=*pcopy++;
		*psate='\0';
		pcopy++;
		psate=theSSID.thePASSWD;
		while(*pcopy!=',')
			*psate++=*pcopy++;
		*psate='\0';
		pcopy++;
		while(*pcopy!=',')
			theSSID.Port=theSSID.Port*10 + *pcopy++ -'0';
		pcopy++;
		while(*pcopy!='\0')
		{
			for(int i=0;i<4;i++)
			{
				do{
					theSSID.SeverIPAddr[i]=theSSID.SeverIPAddr[i]*10+*pcopy++-'0';
				}while(*pcopy!='.' && *pcopy!='\0');
				pcopy++;
			}
		}
		if(wifidefaultconfig(&theSSID,1,eBAUDRATE_115200,1)==0){
			SysStates.wifistates|=WIFINETCONNECT;
		}else{
			SysStates.wifistates&=(uint32_t)~WIFINETCONNECT;
		}
		memset(WifiRxBuf.dat,0,100+2);
		//HAL_UART_Receive_IT(&WifiPort,WifiRxBuf.dat,1);

		WifiUartSend("wifi reconfig finish\r\n",sizeof("wifi reconfig finish\r\n"));
    }
}
// USER END

/*************************** End of file ****************************/
